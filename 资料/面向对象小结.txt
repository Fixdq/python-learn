01 为什么使用函数

	1. 减少代码冗余
	2. 提高程序组织结构，使机构更加清晰
	3. 提高程序的扩展性


02 定义函数与定义类的区别

定义函数之间测语法不执行函数体代码
定义类会立刻执行类体代码，会产生类的名称空间，将类体代码执行过程中产生的名字放到类的名称空间中




01 什么是对象
	对象自是技能与特征的结合体
	特征：变量
	技能：函数

02 什么是类
	类是一系列对象相似的特征和技能的结合体

03 定义类的目的
	是为了调用类产生对象，对象（变量 + 函数）


补充：
	类的使用：
		调用类产生对象
		1.产生一个空对象
		2.将对象本身和括号内的参数，一同传给类的  __init__（）函数，
		3.对象的本质与类一样，都是一个用来存放名字的容器，即名称空间

继承------------------------------------------------------------------------
04 什么是继承
	创建类的方式，创建的子类可以遗传父类的功能和属性

	特点：
		python支持多继承

	优点：
		减少代码的冗余

	缺点：
		把父类与子类强耦合到了一起 
	最后有总结
05 属性查找
	类有两种属性：
		1. 数据属性 ： 类的数据属性是所有对象共享的
		2. 函数属性 ： 类的函数属性是绑定给对象使用的
	
	属性查找的顺序：
		先从对象自己的名称空间----->对象类的名称空间------->类的父类名称空间--------->object ----->没有查找到会抛处异常

06 类中的函数，装饰器
	绑定方法：
		谁来调用就把谁当做函数的第一个参数传入，具有自动传值的特性
		（
		绑定到对象的方法就是：对象调用，就把对象当做函数第一个参数传入
		绑定到累的方法：类调用，就把类当做函数的第一个参数传入
		）
	非绑定方法：
		不与类和函数绑定，就是一个普通的函数，谁都可以调用，没有自动传值特性

	1.绑定到对象的方法（类体中默认就是绑定方法）

		eg:
			def __init__(self,name):
				self.name = name
	
	2.绑定到类的方法（ @classmethod 修饰 ）

		eg:
			@classmethod
			def get_instance(cls)
				return cls('fixd')

	3.非绑定方法	( @staticmethod 修饰 )

		eg：
			@staticmethod
			def say_hi():
				print('hello')

	4. 装饰器

	@property
    def name(self):
        return self.__name

    @name.setter
    def name(self,obj): #obj='EGON'
        if not isinstance(obj,str):
            raise TypeError('名字的值必须是str类型')
        self.__name=obj #self.__name='EGON'

    @name.deleter
    def name(self):
        del self.__name

面向对象额三大特征

python
 --------------封装-------------------
 01 什么是封装
 	封装就是将类的属性和函数进行隐藏起来（即设置成私有的属性），调用者需要通过我们提供的接口进行对象和函数的操作

 	封装的方式：
 		属性名，函数名 前面以双下划线  __开头 
 
 02 注意点：
		1.这种机制不是真正意义上的隐藏，只是语法意义上的变形，知道类名依然可以通过 对象._类名__属性名 进行访问
		2.这个变形的过程只在类定义的阶段发生一次，在定义后的赋值操作不会变形
		3.在继承中，父类如果不想让子类覆盖自己的方法，可以讲方法定义为私有的
 03 封装的意义：
 	封装的意义在于明确内外,在类的内部可以直接使用这些属性，在类的外部不能直接访问使用，想要使用可以在类内部 开辟接口的方式，供外部间接的调用

 	1.封装数据：
 		在接口的基础上，控制外部对数据的操作
 	2.封装方法：
 		隔离复杂度，将类内部复杂的操作隐藏并封装为一个简单的接口，供外部访问，降低调用者使用难度

 --------------继承-------------------
01 什么继承
	创建类的方式，创建的子类可以遗传父类的功能和属性

	特点：
		python支持多继承

	优点：
		减少代码的冗余（子类可以复用父类的属性）

	缺点：
		把父类与子类强耦合到了一起 

02 新式类与经典类
	python3中使用的都是新式类， python2中分为经典类与新式类
	新式类：继承object的类及其子类都是新式类
	经典类：没有继承object的类及其子类

03 再看属性查找：

	继承关系在没有出现菱形的情况下，都是从左到右，从下到上依次查找属性

	菱形情况下：
		经典类：深度优先
		新式类：广度优先（python3中可以通过 mro列表查看 类的继承关系）

04 组合（推荐使用这种方式，解耦程度更高）
	组合就是：在一个类中以另外一个类的对象作为数据属性，称为类的组合

	继承和组合都是重用现有类资源的一种方式：
	继承：是一种‘是’的关系，建立了子类与父类的关系
	组合：是一种‘有’的关系，建立了类与类之间的关系


05 子类调用父类中的方法
	1.指名道姓的调用（不依赖于继承关系）
	2.通过super（）调用（依赖于继承关系）

	注意点：两种方式都可以使用，但在使用过程中 最好统一一种方式的使用

 
 --------------多态-------------------
01 多态
	多态指的是一类事物的多种形态
02 多态性
	（继承的背景下使用，称为多态性，通过抽象方法实现，子类必须实现父类的抽象方法）

		eg:
		import abc
		class File(metaclass=abc.ABCMeta): #同一类事物:文件
		    @abc.abstractmethod
		    def click(self):
		        pass

	多态性是指在不考虑实例类型的情况下使用使用实例

	多态性好处：
		1.增加了程序的灵活性
		2.增加了程序的可扩展性

03 在python中崇尚‘鸭子类型’
	如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子’







